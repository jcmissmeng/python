第十六天
第二课：
		带参数的装饰器（实际上就是三层函数）
第三课：
		动态语言特性-添加属性
第四课：
		为类动态添加方法
第五课：
		为类添加类方法和静态方法
第六课：
		限制类动态添加属性
第七课：
		装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象
		一般callable对象都是函数，但也有例外。只要某个对象重写了__call__()方法，那么这个对象就是callable的
第八课：
		（优化）对象池：避免对象重复创建
		小整数[-5,257)
		单个字符，单个单词
第九课：
		引用计数的内存管理机制
			导致引用计数+1的情况
				对象被创建， 例如a=23
				对象被引用， 例如b=a
				对象被作为参数， 传入到一个函数中， 例如func(a)
				对象作为一个元素， 存储在容器中， 例如list1=[a,a] 
			导致引用计数-1的情况
				对象的别名被显式销毁， 例如del a
				对象的别名被赋予新的对象， 例如a=24
				一个对象离开它的作用域， 例如f函数执行完毕时， func函数中的局部变量（全局变量不会）
				对象所在的容器被销毁， 或从容器中删除对象 
			引用计数为0触发垃圾回收
			缺陷：循环引用 
第十课：
		了解
			垃圾回收后的对象会放在gc.garbage列表里面
			gc.get_threshold() 获取的gc模块中自动执行垃圾回收的频率
			gc.set_threshold(threshold0[, threshold1[, threshold2]) 设置自动执行垃圾回收的频率 
			gc.get_count() 获取当前自动执行垃圾回收的计数器， 返回一个长度为3的列表 
			gc.collect([generation]) 显式进行垃圾回收， 可以输入参数， 0代表只检查第一代的对象， 1代表检查一，
				二代的对象， 2代表检查一， 二， 三代的对象， 如果不传参数， 执行一个full collection， 也就是等
				于传2。 返回不可达（unreachable objects） 对象的数目 
			gc模块唯一处理不了的是循环引用的类都有__del__方法， 所以项目中要避免定义__del__方法 
			引用计数为主，分代收集为辅
第十一课：
		内建属性
		__getattribute__属性访问拦截器
		重写方法内不能出现self.，否则会造成递归
第二课：
		
第二课：
		
第二课：
		
第二课：
		
第二课：
		
第二课：
		
第二课：
		
